;;; Solving the exercises of SICP in Kvasir

(extern malloc (-> UInt (Ptr UInt8)))
(extern read_int64 (-> RealWorld (Cons Int64 RealWorld)))
(extern print_int64 (-> (Cons Int64 RealWorld) (Cons Nil RealWorld)))
(extern print_float64 (-> (Cons Float64 RealWorld) (Cons Nil RealWorld)))

(extern add-int64 (-> (Cons Int64 Int64) Int64))
(extern sub-int64 (-> (Cons Int64 Int64) Int64))
(extern mul-int64 (-> (Cons Int64 Int64) Int64))
(extern div-int64 (-> (Cons Int64 Int64) Int64))

(extern eq-int64 (-> (Cons Int64 Int64) Bool))
(extern neq-int64 (-> (Cons Int64 Int64) Bool))
(extern gt-int64 (-> (Cons Int64 Int64) Bool))
(extern gteq-int64 (-> (Cons Int64 Int64) Bool))
(extern lt-int64 (-> (Cons Int64 Int64) Bool))
(extern lteq-int64 (-> (Cons Int64 Int64) Bool))

(extern add-float64 (-> (Cons Float64 Float64) Float64))
(extern sub-float64 (-> (Cons Float64 Float64) Float64))
(extern mul-float64 (-> (Cons Float64 Float64) Float64))
(extern div-float64 (-> (Cons Float64 Float64) Float64))

(extern eq-float64 (-> (Cons Float64 Float64) Bool))
(extern neq-float64 (-> (Cons Float64 Float64) Bool))
(extern gt-float64 (-> (Cons Float64 Float64) Bool))
(extern gteq-float64 (-> (Cons Float64 Float64) Bool))
(extern lt-float64 (-> (Cons Float64 Float64) Bool))
(extern lteq-float64 (-> (Cons Float64 Float64) Bool))

(extern pcg32_random (-> RealWorld (Cons Int32 RealWorld)))

(define read-int64 read_int64)

(define (print-int64 x)
  (lambda (real-world)
    (print_int64 (cons x real-world))))

(define (print-float64 x)
  (lambda (real-world)
    (print_float64 (cons x real-world))))

(define undef (: (lambda (_) (undef nil))
                 (-> Nil t)))

(define add (: (lambda (_) (undef nil)) (-> (Cons (: t Num) t) t)))
(define sub (: (lambda (_) (undef nil)) (-> (Cons (: t Num) t) t)))
(define mul (: (lambda (_) (undef nil)) (-> (Cons (: t Num) t) t)))
(define div (: (lambda (_) (undef nil)) (-> (Cons (: t Num) t) t)))

(define eq (: (lambda (_) (undef nil))
              (-> (Cons (: t Num) t) Bool)))
(define neq (: (lambda (_) (undef nil))
               (-> (Cons (: t Num) t) Bool)))
(define gt (: (lambda (_) (undef nil))
              (-> (Cons (: t Num) t) Bool)))
(define gteq (: (lambda (_) (undef nil))
                (-> (Cons (: t Num) t) Bool)))
(define lt (: (lambda (_) (undef nil))
              (-> (Cons (: t Num) t) Bool)))
(define lteq (: (lambda (_) (undef nil))
                (-> (Cons (: t Num) t) Bool)))

(define (+ x y) (add (cons x y)))
(define (- x y) (sub (cons x y)))
(define (* x y) (mul (cons x y)))
(define (/ x y) (div (cons x y)))

(define (= x y) (eq (cons x y)))
(define (/= x y) (neq (cons x y)))
(define (> x y) (gt (cons x y)))
(define (>= x y) (gteq (cons x y)))
(define (< x y) (lt (cons x y)))
(define (<= x y) (lteq (cons x y)))

(define (>> io1 io2)
  (lambda (real-world)
    (io2 (cdr (io1 real-world)))))

(define (>>= io f)
  (lambda (real-world)
    (let ((r (io real-world))
          (v (car r))
          (real-world2 (cdr r)))
      (f v real-world2))))

(define (return x)
  (lambda (real-world)
    (cons x real-world)))

(define (iomap f io)
  (lambda (real-world)
    (let ((r (io real-world))
          (v (car r))
          (real-world2 (cdr r)))
      (cons (f v) real-world2))))

;;; 1.3
(define (max x y)
  (if (> x y)
      x
      y))

(define (square x) (* x x))

(define (sum-squares x y)
  (+ (square x) (square y)))

(define (foo x y z)
  (if (> x y)
      (sum-squares x (max y z))
      (sum-squares y (max x z))))
;;;

;;; 1.4
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
;;;

(define (abs x)
  (if (< x 0)
      (- 0 x)
      x))

(define (average x y)
  (/ (+ x y) 2))

(define (sqrt x)
  (let (((improve guess x)
         (average guess (/ x guess)))
        ((good-enough? guess x)
         (< (abs (- (square guess) x)) 0.0001))
        ((sqrt-iter guess x)
         (if (good-enough? guess x)
             guess
             (sqrt-iter (improve guess x) x))))
    (sqrt-iter 1.0 x)))

(define (factorial n)
  (let (((iter p i)
         (if (= i 0)
             p
             (iter (* i p) (- i 1)))))
    (iter 1 n)))

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(define (fib n)
  (let (((fib-iter a b i) (if (= i 0)
                              a
                              (fib-iter b (+ a b) (- i 1)))))
    (fib-iter 0 1 n)))

(define (remainder n d)
  (- n (* (/ n d) d)))

(define (even? n)
  (= (remainder n 2) 0))

;; Exercise 1.16
(define (expt b n)
  (let (((iter acc b i)
         (cond ((= i 0)
                acc)
               ((even? i)
                (iter acc (square b) (/ i 2)))
               (else
                (iter (* acc b) b (- i 1))))))
    (iter 1 b n)))

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (flip f a b) (f b a))

(define (random n)
  (iomap (lambda (r) (remainder (cast r Int64) n))
         pcg32_random))

(define main (io-pipe (>>= (random 10) print-int64)
                      (>>= (random 10) print-int64)
                      (>>= (random 10) print-int64)
                      (>>= (random 10) print-int64)))
