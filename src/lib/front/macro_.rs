// The MIT License (MIT)
//
// Copyright (c) 2015 Johan Johansson
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// TODO: Macro hygiene. Prevent shadowing and such, maybe by letting vars introduced inside the
//       macro be located inside a module generated by the macro.
//       So something like:
//           (def-macro m ()
//               (def-var a (:U64 42))
//               (set a (inc a)))
//       Would expand to:
//           (module m
//               (def-var a (:U64 42)))
//           (unsafe (set m\a (inc m\a)))

use std::collections::{ HashMap, HashSet };
use std::iter::once;

use lib::ScopeStack;
use super::lex::{ TokenTree, TokenTreeMeta, SrcPos };

type Macros<'a> = ScopeStack<&'a str, MacroRules<'a>>;

fn unambiguous_sequences(patts: &[MacroPattern], literals: &HashSet<&str>) -> bool {
	let mut ambiguous_sequence = false;

	for patt in patts {
		match *patt {
			MacroPattern::Ident("...") if ! ambiguous_sequence => ambiguous_sequence = true,
			MacroPattern::Ident("...") => return false,
			MacroPattern::Ident(ident) if literals.contains(ident) => ambiguous_sequence = false,
			_ => (),
		}
	}
	true
}

/// A pattern to be matched against a `TokenTree` as part of macro expansion.
///
/// A `MacroPattern` created as part of a macro definition is guaranteed to be valid
#[derive(Clone, Debug, PartialEq, Eq)]
enum MacroPattern<'a> {
	Ident(&'a str),
	List(Vec<MacroPattern<'a>>),
}
impl<'a> MacroPattern<'a> {
	/// Construct a new, valid `MacroPattern` corresponding to a `TokenTree`
	fn new(ttm: TokenTreeMeta<'a>, literals: &HashSet<&'a str>) -> Self {
		match ttm.tt {
			TokenTree::Ident(ident) => MacroPattern::Ident(ident),
			TokenTree::List(list) => {
				let patts: Vec<_> = list.into_iter()
					.map(|li| MacroPattern::new(li, literals))
					.collect();

				if unambiguous_sequences(&patts, literals) {
					MacroPattern::List(patts)
				} else {
					src_error_panic!(ttm.pos, "Ambiguous pattern")
				}
			},
			_ => src_error_panic!(ttm.pos, "Expected list or ident")
		}
	}

	fn get_ident(&self) -> Option<&str> {
		match *self {
			MacroPattern::Ident(ident) => Some(ident),
			_ => None,
		}
	}

	/// Bind the `TokenTree`, `arg`, to the pattern `self`
	///
	/// If pattern matched, return the bound pattern
	fn bind(&self, arg: TokenTreeMeta<'a>, literals: &HashSet<&'a str>)
		-> Option<HashMap<&'a str, TokenTreeMeta<'a>>>
	{
		match arg.tt {
			TokenTree::List(args) => self.bind_sequence(args, &arg.pos, literals),
			TokenTree::Ident(ident) => match *self {
				MacroPattern::Ident(pi) if literals.contains(pi) && pi == ident =>
					Some(HashMap::new()),
				MacroPattern::Ident(pi) if literals.contains(pi) => None,
				MacroPattern::Ident(pi) => Some(once((pi, arg)).collect()),
				_ => None,
			},
			_ => match *self {
				MacroPattern::Ident(pi) if literals.contains(pi) => None,
				MacroPattern::Ident(pi) => Some(once((pi, arg)).collect()),
				_ => None,
			},
		}
	}

	// `pos` is a fallback in case `args` is empty
	fn bind_sequence(&self,
		args: Vec<TokenTreeMeta<'a>>,
		pos: &SrcPos<'a>,
		literals: &HashSet<&'a str>
	) -> Option<HashMap<&'a str, TokenTreeMeta<'a>>> {
		let mut map = HashMap::new();

		let pos_interval = if args.is_empty() {
			pos.clone()
		} else {
			let mut pos_interval = args[0].pos.clone();
			pos_interval.end = args.last().unwrap().pos.end.clone();
			pos_interval
		};

		match *self {
			MacroPattern::Ident(pi) => if literals.contains(pi) {
				return None;
			} else {
				map.insert(pi, TokenTreeMeta::new_list(args, pos_interval));
			},
			MacroPattern::List(ref patts) => {
				let mut args = args.into_iter().peekable();

				for i in 0 .. patts.len() {
					if patts[i] == MacroPattern::Ident("...") {
						continue;
					}
					if i + 1 < patts.len() && patts[i + 1] == MacroPattern::Ident("...") {
						// Followed by ellipsis. It's a repeating sequence
						let len_til_end = patts[i + 2 ..].iter()
							.position(|pat| pat.get_ident()
								.map(|id| literals.contains(id))
								.unwrap_or(false))
							.map(|j| j + i + 2)
							.unwrap_or(patts.len());
						let keep = len_til_end - (i + 2);

						let mut to_bind = Vec::new();
						loop {
							if let Some(arg) = args.peek() {
								if len_til_end != patts.len()
									&& arg.tt.get_ident() == patts[len_til_end].get_ident()
								{
									break
								}
							} else {
								break
							}
							to_bind.push(args.next().unwrap())
						}
						if keep > to_bind.len() {
							return None;
						}

						let keep_split_pos = to_bind.len() - keep;
						args = to_bind.split_off(keep_split_pos)
							.into_iter()
							.chain(args)
							.collect::<Vec<_>>()
							.into_iter()
							.peekable();

						match patts[i].bind_sequence(to_bind, pos, literals) {
							Some(bound) => map.extend(bound),
							None => return None,
						}
					} else {
						match args.next().and_then(|arg| patts[i].bind(arg, literals)) {
							Some(bound) => map.extend(bound),
							None => return None,
						}
					}
				}
			},
		}
		Some(map)
	}
}

/// A definition of a macro through a series of rules, which are pattern matching cases.
#[derive(Clone, Debug)]
struct MacroRules<'a> {
	literals: HashSet<&'a str>,
	rules: Vec<(MacroPattern<'a>, TokenTreeMeta<'a>)>,
}
impl<'a> MacroRules<'a> {
	/// Construct a new `MacroRules` structure from token trees representing literals and rules
	fn new<I, T>(maybe_literals: Vec<TokenTreeMeta<'a>>, maybe_rules: T) -> MacroRules<'a>
		where
			I: Iterator<Item=TokenTreeMeta<'a>>,
			T: IntoIterator<IntoIter=I, Item=TokenTreeMeta<'a>>
	{
		let literals = maybe_literals.into_iter()
			.map(|item| match item.tt {
				TokenTree::Ident(lit) => lit,
				_ => src_error_panic!(item.pos, "Expected literal identifier"),
			})
			.collect();

		let mut rules = Vec::with_capacity(1);

		for maybe_rule in maybe_rules {
			if let TokenTree::List(mut rule) = maybe_rule.tt {
				if rule.len() != 2 {
					src_error_panic!(
						maybe_rule.pos,
						format!("Expected pattern and template"))
				}

				let template = rule.pop().unwrap();
				let pattern = MacroPattern::new(rule.pop().unwrap(), &literals);

				rules.push((pattern, template))
			} else {
				src_error_panic!(maybe_rule.pos, "Expected list")
			}
		}

		MacroRules{ literals: literals, rules: rules }
	}

	/// Apply a macro to some arguments.
	fn apply_to(&self, args: Vec<TokenTreeMeta<'a>>, pos: &SrcPos<'a>, macros: &mut Macros<'a>)
		-> TokenTreeMeta<'a>
	{
		for &(ref pattern, ref template) in &self.rules {
			if let Some(bound) = pattern.bind_sequence(args.clone(), &pos, &self.literals) {
				let mut template = template.clone();
				template.add_expansion_site(pos.clone());

				return template.expand_macros(macros, &bound)
			}
		}

		src_error_panic!(pos, "No rule matched in macro invocation")
	}
}

impl<'a> TokenTreeMeta<'a> {
	fn substitute_syntax_vars(self, syntax_vars: &HashMap<&str, TokenTreeMeta<'a>>) -> Self {
		match self.tt {
			TokenTree::Ident(ident) => syntax_vars.get(ident).cloned().unwrap_or(self),
			TokenTree::List(list) => TokenTreeMeta::new(
				TokenTree::List(list.map_in_place(|e| e.substitute_syntax_vars(syntax_vars))),
				self.pos),
			_ => self,
		}
	}

	fn expand_macros(self,
		macros: &mut Macros<'a>,
		syntax_vars: &HashMap<&'a str, TokenTreeMeta<'a>>
	) -> TokenTreeMeta<'a> {
		match self.tt {
			TokenTree::Ident(ident) if syntax_vars.contains_key(ident) =>
				TokenTreeMeta::new(syntax_vars[ident].tt.clone(), self.pos)
					.expand_macros(macros, &HashMap::new()),
			TokenTree::List(ref l) if l.len() == 0 =>
				TokenTreeMeta::new_list(vec![], self.pos),
			TokenTree::List(mut sexpr) => match sexpr[0].tt {
				TokenTree::Ident("quote") => TokenTreeMeta::new_list(
					once(sexpr[0].clone())
						.chain(sexpr.drain(1..).map(|arg| arg.substitute_syntax_vars(syntax_vars)))
						.collect(),
					self.pos),
				TokenTree::Ident("begin") => TokenTreeMeta::new_list(once(sexpr[0].clone())
						.chain(expand_macros_in_scope(sexpr.drain(1..), macros, syntax_vars))
						.collect(),
					self.pos),
				TokenTree::Ident(macro_name) if macros.contains_key(macro_name) => {
					let macro_rules = macros.get(macro_name).unwrap().0.clone();

					let args = sexpr.drain(1..)
						.map(|arg| arg.substitute_syntax_vars(syntax_vars))
						.collect();
					macro_rules.apply_to(args, &self.pos, macros)
				},
				_ => TokenTreeMeta::new_list(sexpr.into_iter()
						.map(|arg| arg.expand_macros(macros, syntax_vars))
						.collect(),
					self.pos),
			},
			_ => self,
		}
	}
}

// Expand macros in a block (lexical scope) of token trees
fn expand_macros_in_scope<'a, I, T>(
	scope_items: T,
	macros: &mut Macros<'a>,
	syntax_vars: &HashMap<&'a str, TokenTreeMeta<'a>>
) -> Vec<TokenTreeMeta<'a>>
	where I: Iterator<Item=TokenTreeMeta<'a>>, T: IntoIterator<IntoIter=I, Item=TokenTreeMeta<'a>>
{
	let scope_items = scope_items.into_iter();

	let mut local_macros = HashMap::new();
	// Expressions in block with macro definitions filtered out
	let mut exprs = Vec::new();

	for item in scope_items {
		if let TokenTree::List(mut sexpr) = item.tt {
			if let Some(&TokenTree::Ident("def-macro")) = sexpr.first().map(|ttm| &ttm.tt) {
				let mut parts = sexpr.drain(1..);

				let name = if let Some(name_tree_meta) = parts.next() {
					match name_tree_meta.tt {
						TokenTree::Ident(name) => name,
						_ => src_error_panic!(name_tree_meta.pos, "Expected identifier")
					}
				} else {
					src_error_panic!(item.pos, "Arity mismatch. Expected 3, found 0")
				};

				let literals = if let Some(lits_tree_meta) = parts.next() {
					match lits_tree_meta.tt {
						TokenTree::List(lits) => lits,
						_ => src_error_panic!(lits_tree_meta.pos, "Expected list")
					}
				} else {
					src_error_panic!(item.pos, "Arity mismatch. Expected 3, found 1")
				};

				if local_macros.insert(name, MacroRules::new(literals, parts)).is_some() {
					src_error_panic!(item.pos, format!("Duplicate definition of macro `{}`", name))
				}
			} else {
				exprs.push(TokenTreeMeta::new_list(sexpr, item.pos))
			}
		} else {
			exprs.push(item)
		}
	}

	let mut macros = macros.push_local(&mut local_macros);

	exprs.into_iter()
		.map(|ttm| ttm.expand_macros(&mut macros, syntax_vars))
		.collect()
}

pub fn expand_macros<'a>(tts: Vec<TokenTreeMeta<'a>>) -> Vec<TokenTreeMeta<'a>> {
	expand_macros_in_scope(tts, &mut Macros::new(), &HashMap::new())
}
